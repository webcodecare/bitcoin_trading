import { storage } from '../storage';
import { smsService } from './smsService';
import { telegramService } from './telegramService';

interface NotificationPayload {
  ticker: string;
  signalType: 'buy' | 'sell';
  price: number;
  confidence: number;
  timeframe?: string;
  message?: string;
}

interface NotificationChannel {
  type: 'email' | 'sms' | 'telegram' | 'discord' | 'webhook';
  enabled: boolean;
  config: any;
}

interface NotificationLog {
  id: string;
  userId: string;
  channel: string;
  recipient: string;
  subject: string;
  message: string;
  status: 'pending' | 'sent' | 'delivered' | 'failed' | 'bounced';
  attempts: number;
  sentAt?: Date;
  deliveredAt?: Date;
  failureReason?: string;
  alertType: 'buy' | 'sell' | 'price_alert' | 'system';
  ticker?: string;
  metadata?: any;
}

interface NotificationStats {
  totalSent: number;
  deliveryRate: number;
  avgDeliveryTime: number;
  failureRate: number;
  channelBreakdown: {
    [key: string]: {
      sent: number;
      delivered: number;
      failed: number;
    };
  };
}

class NotificationService {
  private notificationLogs: NotificationLog[] = [];
  private channelConfigs: Map<string, NotificationChannel> = new Map();
  
  constructor() {
    this.initializeChannels();
  }

  private initializeChannels() {
    // Initialize default channel configurations
    this.channelConfigs.set('email', {
      type: 'email',
      enabled: true,
      config: {
        provider: 'smtp',
        host: process.env.SMTP_HOST || 'smtp.gmail.com',
        port: parseInt(process.env.SMTP_PORT || '587'),
        secure: false,
        auth: {
          user: process.env.SMTP_USER,
          pass: process.env.SMTP_PASS
        }
      }
    });

    this.channelConfigs.set('sms', {
      type: 'sms',
      enabled: false, // Requires Twilio configuration
      config: {
        provider: 'twilio',
        accountSid: process.env.TWILIO_ACCOUNT_SID,
        authToken: process.env.TWILIO_AUTH_TOKEN,
        fromNumber: process.env.TWILIO_PHONE_NUMBER
      }
    });

    this.channelConfigs.set('telegram', {
      type: 'telegram',
      enabled: false, // Requires bot token
      config: {
        botToken: process.env.TELEGRAM_BOT_TOKEN,
        baseUrl: 'https://api.telegram.org/bot'
      }
    });

    this.channelConfigs.set('discord', {
      type: 'discord',
      enabled: false, // Requires webhook configuration
      config: {
        webhookUrl: process.env.DISCORD_WEBHOOK_URL
      }
    });
  }

  async broadcastSignalToAllUsers(payload: NotificationPayload): Promise<void> {
    try {
      const users = await storage.getAllUsers();
      const activeUsers = users.filter(user => user.isActive);

      console.log(`Broadcasting ${payload.signalType} signal for ${payload.ticker} to ${activeUsers.length} users`);

      for (const user of activeUsers) {
        await this.sendSignalNotification(user.id, payload);
      }
    } catch (error) {
      console.error('Error broadcasting signal to all users:', error);
    }
  }

  async sendSignalNotification(userId: string, payload: NotificationPayload): Promise<void> {
    try {
      const user = await storage.getUser(userId);
      if (!user || !user.isActive) return;

      const userSettings = await storage.getUserSettings(userId);
      if (!userSettings) return;

      const message = this.formatSignalMessage(payload);
      const subject = `${payload.signalType.toUpperCase()} Signal: ${payload.ticker}`;

      // Send via enabled channels
      if (userSettings.notificationEmail && this.isChannelEnabled('email')) {
        await this.sendEmailNotification(userId, user.email, subject, message, payload);
      }

      if (userSettings.notificationSms && this.isChannelEnabled('sms')) {
        // Note: Phone number would need to be stored in user settings
        await this.sendSmsNotification(userId, '+1234567890', message, payload);
      }

      if (userSettings.notificationPush && this.isChannelEnabled('telegram')) {
        // Note: Telegram chat ID would need to be stored in user settings
        await this.sendTelegramNotification(userId, '123456789', message, payload);
      }

    } catch (error) {
      console.error(`Error sending notification to user ${userId}:`, error);
    }
  }

  private formatSignalMessage(payload: NotificationPayload): string {
    const emoji = payload.signalType === 'buy' ? 'üü¢' : 'üî¥';
    const action = payload.signalType === 'buy' ? 'BUY' : 'SELL';
    
    return `${emoji} ${action} SIGNAL ALERT

üí∞ Symbol: ${payload.ticker}
üíµ Price: $${payload.price.toLocaleString()}
üìä Confidence: ${payload.confidence}%
${payload.timeframe ? `‚è±Ô∏è Timeframe: ${payload.timeframe}` : ''}

${payload.message || 'Trade signal generated by our advanced algorithm.'}

‚ö° Act fast - markets move quickly!

CryptoStrategy Pro`;
  }

  private async sendEmailNotification(
    userId: string, 
    email: string, 
    subject: string, 
    message: string, 
    payload: NotificationPayload
  ): Promise<void> {
    const logEntry: NotificationLog = {
      id: this.generateId(),
      userId,
      channel: 'email',
      recipient: email,
      subject,
      message,
      status: 'pending',
      attempts: 0,
      alertType: payload.signalType,
      ticker: payload.ticker,
      metadata: { confidence: payload.confidence, timeframe: payload.timeframe }
    };

    try {
      // Simulate email sending (replace with actual email service)
      console.log(`[EMAIL] Sending to ${email}: ${subject}`);
      
      // In real implementation, use nodemailer or similar
      await this.simulateDelay(1000); // Simulate send time
      
      logEntry.status = 'sent';
      logEntry.sentAt = new Date();
      logEntry.attempts = 1;

      // Simulate delivery confirmation (90% success rate)
      if (Math.random() > 0.1) {
        logEntry.status = 'delivered';
        logEntry.deliveredAt = new Date();
      } else {
        logEntry.status = 'failed';
        logEntry.failureReason = 'SMTP timeout';
      }

    } catch (error) {
      logEntry.status = 'failed';
      logEntry.failureReason = error instanceof Error ? error.message : 'Unknown error';
      logEntry.attempts = 1;
    }

    this.notificationLogs.push(logEntry);
  }

  private async sendSmsNotification(
    userId: string, 
    phoneNumber: string, 
    message: string, 
    payload: NotificationPayload
  ): Promise<void> {
    const logEntry: NotificationLog = {
      id: this.generateId(),
      userId,
      channel: 'sms',
      recipient: phoneNumber,
      subject: `${payload.signalType.toUpperCase()} ${payload.ticker}`,
      message: smsService.formatSignalMessage(payload),
      status: 'pending',
      attempts: 0,
      alertType: payload.signalType,
      ticker: payload.ticker
    };

    try {
      console.log(`[SMS] Sending to ${phoneNumber}: ${logEntry.subject}`);
      
      logEntry.attempts = 1;
      logEntry.sentAt = new Date();
      
      const result = await smsService.sendSMS({
        to: phoneNumber,
        message: logEntry.message,
        subject: logEntry.subject
      });

      if (result.success) {
        logEntry.status = 'delivered';
        logEntry.deliveredAt = new Date();
        logEntry.metadata = { messageId: result.messageId };
      } else {
        logEntry.status = 'failed';
        logEntry.failureReason = result.error || 'SMS delivery failed';
      }

    } catch (error) {
      logEntry.status = 'failed';
      logEntry.failureReason = error instanceof Error ? error.message : 'SMS service error';
    }

    this.notificationLogs.push(logEntry);
  }

  private async sendTelegramNotification(
    userId: string, 
    chatId: string, 
    message: string, 
    payload: NotificationPayload
  ): Promise<void> {
    const logEntry: NotificationLog = {
      id: this.generateId(),
      userId,
      channel: 'telegram',
      recipient: chatId,
      subject: `${payload.signalType.toUpperCase()} ${payload.ticker}`,
      message: telegramService.formatSignalMessage(payload),
      status: 'pending',
      attempts: 0,
      alertType: payload.signalType,
      ticker: payload.ticker
    };

    try {
      console.log(`[TELEGRAM] Sending to chat ${chatId}: ${logEntry.subject}`);
      
      logEntry.attempts = 1;
      logEntry.sentAt = new Date();
      
      const result = await telegramService.sendMessage({
        chatId: chatId,
        message: logEntry.message,
        parseMode: 'HTML',
        disableWebPagePreview: false
      });

      if (result.success) {
        logEntry.status = 'delivered';
        logEntry.deliveredAt = new Date();
        logEntry.metadata = { messageId: result.messageId };
      } else {
        logEntry.status = 'failed';
        logEntry.failureReason = result.error || 'Telegram delivery failed';
      }

    } catch (error) {
      logEntry.status = 'failed';
      logEntry.failureReason = error instanceof Error ? error.message : 'Telegram API error';
    }

    this.notificationLogs.push(logEntry);
  }

  async getNotificationStats(range: string = '24h'): Promise<NotificationStats> {
    const cutoffTime = this.getCutoffTime(range);
    const relevantLogs = this.notificationLogs.filter(log => 
      log.sentAt && log.sentAt >= cutoffTime
    );

    const totalSent = relevantLogs.length;
    const delivered = relevantLogs.filter(log => log.status === 'delivered').length;
    const failed = relevantLogs.filter(log => log.status === 'failed').length;

    const channelBreakdown: { [key: string]: { sent: number; delivered: number; failed: number; } } = {};
    
    for (const log of relevantLogs) {
      if (!channelBreakdown[log.channel]) {
        channelBreakdown[log.channel] = { sent: 0, delivered: 0, failed: 0 };
      }
      channelBreakdown[log.channel].sent++;
      if (log.status === 'delivered') channelBreakdown[log.channel].delivered++;
      if (log.status === 'failed') channelBreakdown[log.channel].failed++;
    }

    // Calculate average delivery time
    const deliveredLogs = relevantLogs.filter(log => 
      log.status === 'delivered' && log.sentAt && log.deliveredAt
    );
    
    const avgDeliveryTime = deliveredLogs.length > 0 
      ? deliveredLogs.reduce((sum, log) => {
          const deliveryTime = (log.deliveredAt!.getTime() - log.sentAt!.getTime()) / 1000;
          return sum + deliveryTime;
        }, 0) / deliveredLogs.length
      : 0;

    return {
      totalSent,
      deliveryRate: totalSent > 0 ? (delivered / totalSent) * 100 : 0,
      avgDeliveryTime: parseFloat(avgDeliveryTime.toFixed(2)),
      failureRate: totalSent > 0 ? (failed / totalSent) * 100 : 0,
      channelBreakdown
    };
  }

  getNotificationLogs(channel: string = 'all', limit: number = 100): NotificationLog[] {
    let logs = this.notificationLogs;
    
    if (channel !== 'all') {
      logs = logs.filter(log => log.channel === channel);
    }

    return logs
      .sort((a, b) => (b.sentAt?.getTime() || 0) - (a.sentAt?.getTime() || 0))
      .slice(0, limit);
  }

  getChannelHealth(): Array<{
    channel: string;
    status: 'healthy' | 'degraded' | 'down';
    uptime: number;
    lastFailure?: string;
    configStatus: 'configured' | 'missing_config' | 'invalid_config';
    rateLimitStatus: 'normal' | 'throttled' | 'blocked';
  }> {
    return Array.from(this.channelConfigs.entries()).map(([channel, config]) => ({
      channel,
      status: 'healthy' as const,
      uptime: 99.9,
      configStatus: this.getConfigStatus(channel),
      rateLimitStatus: 'normal' as const
    }));
  }

  private getConfigStatus(channel: string): 'configured' | 'missing_config' | 'invalid_config' {
    switch (channel) {
      case 'email':
        return 'configured'; // Email is always configured for demo
      case 'sms':
        return smsService.getConfigStatus();
      case 'telegram':
        return telegramService.getConfigStatus();
      case 'discord':
        return process.env.DISCORD_WEBHOOK_URL ? 'configured' : 'missing_config';
      default:
        return 'missing_config';
    }
  }

  async testChannel(channel: string): Promise<boolean> {
    try {
      console.log(`Testing ${channel} channel...`);
      
      let testResult = false;
      
      switch (channel) {
        case 'email':
          // Email test always succeeds for demo
          testResult = true;
          break;
          
        case 'sms':
          const smsTest = await smsService.testConnection();
          testResult = smsTest.success;
          if (!testResult) {
            console.error('SMS test failed:', smsTest.error);
          }
          break;
          
        case 'telegram':
          const telegramTest = await telegramService.testConnection();
          testResult = telegramTest.success;
          if (!testResult) {
            console.error('Telegram test failed:', telegramTest.error);
          }
          break;
          
        case 'discord':
          // Discord webhook test (placeholder)
          testResult = !!process.env.DISCORD_WEBHOOK_URL;
          break;
          
        default:
          testResult = false;
      }
      
      // Create test log entry
      const testLog: NotificationLog = {
        id: this.generateId(),
        userId: 'test',
        channel,
        recipient: channel === 'email' ? 'test@example.com' : 'test_recipient',
        subject: 'Test Notification',
        message: 'This is a test notification from CryptoStrategy Pro',
        status: testResult ? 'delivered' : 'failed',
        attempts: 1,
        sentAt: new Date(),
        deliveredAt: testResult ? new Date() : undefined,
        failureReason: testResult ? undefined : 'Channel test failed',
        alertType: 'system'
      };

      this.notificationLogs.push(testLog);
      return testResult;
    } catch (error) {
      console.error(`Error testing ${channel} channel:`, error);
      return false;
    }
  }

  async retryNotification(notificationId: string): Promise<boolean> {
    const log = this.notificationLogs.find(log => log.id === notificationId);
    if (!log || log.status !== 'failed') return false;

    log.attempts++;
    log.status = 'pending';

    // Simulate retry
    await this.simulateDelay(1000);
    
    // 70% success rate on retry
    if (Math.random() > 0.3) {
      log.status = 'delivered';
      log.deliveredAt = new Date();
      return true;
    } else {
      log.status = 'failed';
      log.failureReason = 'Retry failed';
      return false;
    }
  }

  private isChannelEnabled(channel: string): boolean {
    switch (channel) {
      case 'email':
        return true; // Email always enabled for demo
      case 'sms':
        return smsService.isConfigured();
      case 'telegram':
        return telegramService.isConfigured();
      case 'discord':
        return !!process.env.DISCORD_WEBHOOK_URL;
      default:
        return false;
    }
  }

  private getCutoffTime(range: string): Date {
    const now = new Date();
    switch (range) {
      case '1h': return new Date(now.getTime() - 60 * 60 * 1000);
      case '24h': return new Date(now.getTime() - 24 * 60 * 60 * 1000);
      case '7d': return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      case '30d': return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      default: return new Date(now.getTime() - 24 * 60 * 60 * 1000);
    }
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private simulateDelay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export const notificationService = new NotificationService();
export type { NotificationPayload, NotificationLog, NotificationStats };